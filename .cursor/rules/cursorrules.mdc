# Coding Rules for NestJS and TypeScript Projects

# I. Kaopiz checklist coding

## 1. Không có code/chức năng thừa (Clean code)
- (PASS/FAIL) Không có code/comment thừa, lặp lại, không cần thiết
- (PASS/FAIL) Tránh sự trùng lặp (DRY principle)
- (PASS/FAIL) Đặt tên biến và hàm có ý nghĩa
- (PASS/FAIL) Giới hạn độ dài function (tối đa 20-30 dòng)

Ví dụ:
```typescript
// Bad (Function and parameters do not have meaningful names)
function p(u, db) {
    // Process user
    return;
}

// Good
function processUserData(user: User, db: DatabaseService): UserResponse {
    /** Process and transform user data. */
    return;
}
```

## 2. Có comment cho những đoạn logic khó hiểu
- (PASS/FAIL) Có comment cho những đoạn logic khó hiểu hoặc phức tạp

Ví dụ:
```typescript
// Bad
function calculateTotal(cart: CartItem[]): number {
    return cart.reduce((total, item) => total + item.price * item.quantity * (1 - item.discount / 100), 0);
}

// Good
function calculateTotal(cart: CartItem[]): number {
    /**
     * Calculate total cart value including discounts.
     * Formula: Sum of (item price * quantity * (1 - discount percentage/100))
     */
    return cart.reduce((total, item) => total + item.price * item.quantity * (1 - item.discount / 100), 0);
}
```

## 3. Xử lý ngoại lệ (Error handling)
- (PASS/FAIL) Sử dụng HTTPException với status code phù hợp
- (PASS/FAIL) Tạo exception handlers tập trung
- (PASS/FAIL) Tránh "swallowing exceptions" (bắt ngoại lệ nhưng không xử lý)
- (PASS/FAIL) Tránh để lộ thông tin nhạy cảm trong message của exception

Ví dụ:
```typescript
// Bad
@Get('/users/:id')
async getUser(@Param('id') id: string): Promise<User> {
    const user = await this.userService.findById(id);
    if (!user) {
        return null; // No proper error handling
    }
    return user;
}

// Good
@Get('/users/:id')
async getUser(@Param('id') id: string): Promise<User> {
    const user = await this.userService.findById(id);
    if (!user) {
        throw new HttpException(`User with id ${id} not found`, HttpStatus.NOT_FOUND);
    }
    return user;
}
```

## 4. Quản lý transactions (Transaction management)
- (PASS/FAIL) Luôn xử lý rollback trong trường hợp lỗi
- (PASS/FAIL) Sử dụng context manager để quản lý transactions
- (PASS/FAIL) Xuất log lỗi khi có lỗi transaction xảy ra

Ví dụ:
```typescript
// Bad
async transferFunds(fromAccountId: string, toAccountId: string, amount: number): Promise<void> {
    const fromAccount = await this.accountRepository.findOne(fromAccountId);
    const toAccount = await this.accountRepository.findOne(toAccountId);

    if (!fromAccount || !toAccount) {
        throw new Error('One or both accounts not found');
    }

    fromAccount.balance -= amount;
    toAccount.balance += amount;

    await this.accountRepository.save(fromAccount);
    await this.accountRepository.save(toAccount);
}

// Good
async transferFunds(fromAccountId: string, toAccountId: string, amount: number): Promise<void> {
    await this.dataSource.transaction(async (manager) => {
        const fromAccount = await manager.findOne(Account, fromAccountId, { lock: { mode: 'pessimistic_write' } });
        const toAccount = await manager.findOne(Account, toAccountId, { lock: { mode: 'pessimistic_write' } });

        if (!fromAccount || !toAccount) {
            throw new Error('One or both accounts not found');
        }

        if (fromAccount.balance < amount) {
            throw new Error('Insufficient funds');
        }

        fromAccount.balance -= amount;
        toAccount.balance += amount;

        await manager.save(fromAccount);
        await manager.save(toAccount);
    });
}
```

## 5. Performance

### 5.1. Tối ưu hóa database
- (PASS/FAIL) Sử dụng các indexes phù hợp
- (PASS/FAIL) Eager loading để tránh N+1 queries
- (PASS/FAIL) Sử dụng paging và limiting cho các collections lớn
- (PASS/FAIL) Sử dụng connection pooling cho scalability
- (PASS/FAIL) Sử dụng batch operations cho multiple records
- (PASS/FAIL) Chọn transaction isolation levels phù hợp
- (PASS/FAIL) Áp dụng concurrency controls (optimistic or pessimistic locking)

Ví dụ:
```typescript
// Bad - N+1 problem
const users = await this.userRepository.find();
for (const user of users) {
    console.log(await user.posts); // Causes separate queries for each user
}

// Good - Eager loading
const users = await this.userRepository.find({ relations: ['posts'] });
for (const user of users) {
    console.log(user.posts); // No additional queries
}
```

```typescript
// Bad - Individual saves in a loop
async addMultipleUsers(users: User[]) {
    for (const user of users) {
        await this.userRepository.save(user); // Inefficient, creates many transactions
    }
}

// Good - Batch operation
async addMultipleUsers(users: User[]) {
    await this.userRepository.save(users); // Single operation for multiple entities
}
```

#### 5.2. Caching
- (PASS/FAIL) Triển khai caching cho các truy vấn tốn kém
- (PASS/FAIL) Sử dụng Redis hoặc Memcached cho caching
- (PASS/FAIL) Áp dụng cache invalidation strategies.
- (PASS/FAIL) Đặt TTL (Time To Live) cho cached items.
- (PASS/FAIL) Sử dụng cache keys để uniquely identify the data.
- (PASS/FAIL) Implement cache serialization for complex objects.
- (PASS/FAIL) Handle cache failures gracefully.

```typescript
// Using in-memory caching
@Injectable()
export class ExpensiveService {
    private cache = new Map<string, any>();

    async getExpensiveCalculation(param1: string, param2: number): Promise<any> {
        const cacheKey = `${param1}-${param2}`;
        if (this.cache.has(cacheKey)) {
            return this.cache.get(cacheKey);
        }

        const result = await this.performExpensiveCalculation(param1, param2);
        this.cache.set(cacheKey, result);
        return result;
    }

    private async performExpensiveCalculation(param1: string, param2: number): Promise<any> {
        // Complex logic
        return {};
    }
}
```

## 6. Async/await/Concurrency
- (PASS/FAIL) Sử dụng async/await cho I/O bound operations
- (PASS/FAIL) Hiểu được sự khác biệt giữa I/O bound và CPU bound
- (PASS/FAIL) Sử dụng scheduler/worker để chạy các task đa luồng (multi-threading) (nếu có)
- (PASS/FAIL) Không blocking flow xử lý chính hoặc event loop với các task CPU-intensive.
- (PASS/FAIL) Kiểm soát concurrency với semaphores hoặc rate limiters.
- (PASS/FAIL) Xử lý task cancellation chính xác.

Ví dụ:
```typescript
// Bad
@Get('/users/:id')
getUser(@Param('id') id: string): User {
    return this.userService.findById(id); // Blocking operation
}

// Good
@Get('/users/:id')
async getUser(@Param('id') id: string): Promise<User> {
    return await this.userService.findById(id); // Non-blocking
}
```

```typescript
// Bad - CPU-intensive work blocks the event loop
@Get('/analyze')
async analyzeData(@Body() data: any): Promise<AnalysisResult> {
    // This will block the event loop and impact all requests
    return await this.performHeavyCpuCalculation(data);
}

// Good - Offloading CPU-intensive work
@Get('/analyze')
async analyzeData(@Body() data: any): Promise<AnalysisResult> {
    // Use a worker thread or queue system for CPU-bound work
    return await this.workerService.scheduleTask('heavyCalculation', data);
}
```

```typescript
// Bad - Uncontrolled concurrency may overwhelm external services
@Get('/fetch-all')
async fetchAllData(): Promise<DataResult[]> {
    const urls = await this.getUrlsToFetch();
    // This might launch too many requests simultaneously
    const results = await Promise.all(urls.map(url =>
        this.httpService.get(url).toPromise()
    ));
    return results.map(res => res.data);
}

// Good - Controlled concurrency
@Get('/fetch-all')
async fetchAllData(): Promise<DataResult[]> {
    const urls = await this.getUrlsToFetch();
    const results = [];

    // Process only 5 requests at a time
    const concurrencyLimit = 5;
    const chunks = this.chunkArray(urls, concurrencyLimit);

    for (const chunk of chunks) {
        const chunkResults = await Promise.all(
            chunk.map(url => this.httpService.get(url).toPromise())
        );
        results.push(...chunkResults.map(res => res.data));
    }

    return results;
}

// Helper method for processing in chunks
private chunkArray<T>(array: T[], size: number): T[][] {
    const chunks = [];
    for (let i = 0; i < array.length; i += size) {
        chunks.push(array.slice(i, i + size));
    }
    return chunks;
}
```

## 7. Error Handling & Logging
- (PASS/FAIL) Sử dụng logging module thay vì print
- (PASS/FAIL) Định cấu hình các log levels phù hợp
- (PASS/FAIL) Log thông tin về các lỗi quan trọng, nhưng không lộ thông tin nhạy cảm

Ví dụ:
```typescript
// Bad
console.log('Error creating user:', error);

// Good
import { Logger } from '@nestjs/common';

const logger = new Logger('UserService');
logger.error('Error creating user', error.stack);
```

## 8. Constants/Environment variables
- (PASS/FAIL) Không sử dụng hardcoded constants cho các thông số quan trọng. Mà sử dụng environment variables.
- (PASS/FAIL) Sử dụng secrets module để lưu trữ các biến môi trường nhạy cảm (nếu cần)
- (PASS/FAIL) Các constants phải được cân nhắc để đưa vào environment variables (nếu bị thay đổi theo môi trường), hoặc có thể được đưa vào class constant như constants.py

```typescript
// Bad
const SECRET_KEY = 'your-secret-key';

// Good
const SECRET_KEY = process.env.SECRET_KEY;
```

## 9. Libraries
- (PASS/FAIL) Không sử dụng các libraries không cần thiết
- (PASS/FAIL) Chỉ sử dụng các libraries có nguồn gốc rõ ràng và tin cậy (e.g., official NestJS packages, well-maintained npm packages).
- (PASS/FAIL) Prefer TypeScript-native libraries with proper type definitions.

## 10. Bảo mật xác thực
- (PASS/FAIL) Luôn băm mật khẩu, không lưu trữ mật khẩu văn bản thuần túy
- (PASS/FAIL) Luôn sử dụng JWT hoặc OAuth2.
- (PASS/FAIL) Prevent SQL injection by using parameterized queries.
- (PASS/FAIL) Implement proper CORS configuration.
- (PASS/FAIL) Use rate limiting for authentication endpoints.
- (PASS/FAIL) Implement role-based access control (RBAC).
- (PASS/FAIL) Configure Helmet for secure HTTP headers.
- (PASS/FAIL) Implement CSRF protection for browser-based clients.
- (PASS/FAIL) Validate all user inputs
- (PASS/FAIL) Set secure and HTTP-only flags for cookies.
- (PASS/FAIL) Regularly scan dependencies for vulnerabilities.

Ví dụ:
```typescript
// Bad
const user = await this.userRepository.query(`SELECT * FROM users WHERE username = '${username}'`);

// Good
const user = await this.userRepository.findOne({ where: { username } });
```

```typescript
// Bad - Plain text passwords
@Post('auth/register')
async register(@Body() userData: CreateUserDto) {
    const user = await this.userRepository.save({
        ...userData,
        password: userData.password // Plain text password!
    });
    return user;
}
// Good - Hashing passwords
@Injectable()
export class AuthService {
    constructor(
        private readonly userRepository: UserRepository,
        private readonly jwtService: JwtService,
    ) {}

    async register(userData: CreateUserDto) {
        const hashedPassword = await bcrypt.hash(userData.password, 10);
        const user = await this.userRepository.save({
            ...userData,
            password: hashedPassword
        });

        // Remove password from response
        const { password, ...result } = user;
        return result;
    }

    async validateUser(username: string, password: string) {
        const user = await this.userRepository.findOne({ where: { username } });
        if (!user) return null;

        const isPasswordValid = await bcrypt.compare(password, user.password);
        if (!isPasswordValid) return null;

        // Remove password from response
        const { password: _, ...result } = user;
        return result;
    }
}
// Good - Implementing CORS properly
// main.ts
async function bootstrap() {
    const app = await NestFactory.create(AppModule);

    // Configure CORS with specific origin
    app.enableCors({
        origin: process.env.ALLOWED_ORIGINS.split(','),
        methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
        credentials: true,
    });

    await app.listen(3000);
}

// Good - Implementing rate limiting
// main.ts
import { rateLimit } from 'express-rate-limit';

async function bootstrap() {
    const app = await NestFactory.create(AppModule);

    app.use(
        '/auth',
        rateLimit({
            windowMs: 15 * 60 * 1000, // 15 minutes
            max: 100, // limit each IP to 100 requests per windowMs
            message: 'Too many login attempts, please try again later',
        }),
    );

    await app.listen(3000);
}

// Bad - No role-based access control
@Controller('admin')
export class AdminController {
    @Get('users')
    getAllUsers() {
        return this.userService.findAll();
    }
}

// Good - Role-based access control with Guards
@Injectable()
export class RolesGuard implements CanActivate {
    constructor(private reflector: Reflector) {}

    canActivate(context: ExecutionContext): boolean {
        const requiredRoles = this.reflector.getAllAndOverride<string[]>('roles', [
            context.getHandler(),
            context.getClass(),
        ]);

        if (!requiredRoles) {
            return true;
        }

        const { user } = context.switchToHttp().getRequest();
        return requiredRoles.some((role) => user.roles?.includes(role));
    }
}

// Define roles decorator
export const Roles = (...roles: string[]) => SetMetadata('roles', roles);

// Use in controllers
@Controller('admin')
@UseGuards(JwtAuthGuard, RolesGuard)
export class AdminController {
    @Get('users')
    @Roles('admin')
    getAllUsers() {
        return this.userService.findAll();
    }
}

// Good - Secure cookie configuration
@Injectable()
export class AuthService {
    async login(user: any) {
        const payload = { username: user.username, sub: user.userId };
        return {
            accessToken: this.jwtService.sign(payload),
        };
    }
}

@Controller('auth')
export class AuthController {
    @Post('login')
    @HttpCode(200)
    async login(@Res({ passthrough: true }) response: Response, @Body() loginDto: LoginDto) {
        const { accessToken } = await this.authService.login(loginDto);

        // Set secure cookie with token
        response.cookie('token', accessToken, {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production',
            sameSite: 'strict',
            maxAge: 24 * 60 * 60 * 1000, // 1 day
        });

        return { message: 'Login successful' };
    }
}
```

## II. NestJS-Specific Rules

### 1. Project Structure
- (PASS/FAIL) Organize the project into modules, controllers, services, and repositories.
- (PASS/FAIL) Use kebab-case for file and folder names.
- (PASS/FAIL) Group related files within feature modules.
- (PASS/FAIL) Maintain consistent file naming patterns.
- (PASS/FAIL) Separate domain logic from infrastructure concerns.
- (PASS/FAIL) Keep the module structure flat where possible.
- (PASS/FAIL) Place shared code in dedicated modules.
- (PASS/FAIL) Follow the NestJS file naming conventions.
- (PASS/FAIL) Organize tests alongside the files they test.

**Examples:**

```typescript
// File naming conventions
// users.controller.ts
// users.service.ts
// users.module.ts
// user.entity.ts
// create-user.dto.ts
// update-user.dto.ts
```

Example project structure
src/
├── app.module.ts # Root application module
├── main.ts # Application entry point
│
├── common/ # Shared resources
│ ├── constants/ # Global constants
│ ├── decorators/ # Custom decorators
│ ├── dto/ # Shared DTOs
│ ├── enums/ # Shared enumerations
│ ├── exceptions/ # Custom exceptions
│ ├── filters/ # Exception filters
│ ├── guards/ # Guards
│ ├── interfaces/ # Interfaces
│ ├── interceptors/ # Interceptors
│ ├── middleware/ # Custom middleware
│ ├── pipes/ # Custom pipes
│ └── utils/ # Utility functions
│
├── config/ # Configuration
│ ├── configuration.ts # Configuration options
│ ├── validation.schema.ts # Env validation schema
│ └── config.module.ts # Config module
│
├── modules/ # Feature modules
│ ├── auth/ # Authentication module
│ │ ├── auth.controller.ts
│ │ ├── auth.module.ts
│ │ ├── auth.service.ts
│ │ ├── dto/
│ │ │ ├── login.dto.ts
│ │ │ └── register.dto.ts
│ │ ├── guards/
│ │ │ └── jwt-auth.guard.ts
│ │ └── strategies/
│ │ └── jwt.strategy.ts
│ │
│ ├── users/ # Users module
│ │ ├── dto/
│ │ │ ├── create-user.dto.ts
│ │ │ └── update-user.dto.ts
│ │ ├── entities/
│ │ │ └── user.entity.ts
│ │ ├── users.controller.ts
│ │ ├── users.module.ts
│ │ ├── users.repository.ts
│ │ ├── users.service.ts
│ │ └── users.service.spec.ts
│ │
│ └── products/ # Products module
│ ├── dto/
│ ├── entities/
│ ├── products.controller.ts
│ ├── products.module.ts
│ ├── products.service.ts
│ └── products.service.spec.ts
│
└── database/ # Database configuration
├── migrations/ # TypeORM migrations
├── seeds/ # Database seeders
└── database.module.ts # Database module

// Bad - Mixed concerns in a module
src/users/
├── user.controller.ts
├── user.service.ts
├── user.module.ts
├── user.entity.ts
├── auth.service.ts # Auth logic mixed with user module
├── email.service.ts # Email logic mixed with user module

// Good - Clear separation of concerns
src/modules/
├── users/
│ ├── users.controller.ts
│ ├── users.service.ts
│ ├── users.module.ts
│ └── entities/
│ └── user.entity.ts
├── auth/
│ ├── auth.controller.ts
│ ├── auth.service.ts
│ └── auth.module.ts
├── notifications/
│ ├── email.service.ts
│ └── notifications.module.ts

### 2. Naming Conventions

- (PASS/FAIL) **Classes**: PascalCase (e.g., `UserService`, `OrderController`).
- (PASS/FAIL) **Functions/Methods**: camelCase (e.g., `getUserById`, `validateEmail`).
- (PASS/FAIL) **Variables**: camelCase (e.g., `userId`, `emailAddress`).
- (PASS/FAIL) **Constants**: UPPER_CASE (e.g., `MAX_LOGIN_ATTEMPTS`, `DEFAULT_PAGE_SIZE`).

### 4. Validation

- (PASS/FAIL) Use `class-validator` and `class-transformer` for input validation.

**Examples:**

```typescript
import { IsEmail, IsString, MinLength } from 'class-validator';

export class CreateUserDto {
    @IsString()
    @MinLength(3)
    username: string;

    @IsEmail()
    email: string;

    @IsString()
    @MinLength(6)
    password: string;
}
```

### 5. NestJS core (shared/common) modules guidelines

- (PASS/FAIL) Global filters for exception handling.
- (PASS/FAIL) Global middlewares for request management.
- (PASS/FAIL) Guards for permission management.
- (PASS/FAIL) Interceptors for request management.

### 6. NestJS Module Structure

- (PASS/FAIL) One module per main domain/route.
- (PASS/FAIL) One controller for its route.
- (PASS/FAIL) Additional controllers for secondary routes when needed.
- (PASS/FAIL) Keep models folder with data types.
- (PASS/FAIL) Use DTOs validated with class-validator for inputs.
- (PASS/FAIL) Declare simple types for outputs.
- (PASS/FAIL) Create services module with business logic and persistence.
- (PASS/FAIL) Define entities for data persistence.
- (PASS/FAIL) Maintain one service per entity.

**Examples:**

```typescript
// Good - Complete module structure (products.module.ts)
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ProductsController } from './products.controller';
import { CategoriesController } from './categories.controller';
import { ProductsService } from './services/products.service';
import { CategoriesService } from './services/categories.service';
import { Product } from './entities/product.entity';
import { Category } from './entities/category.entity';

@Module({
  imports: [TypeOrmModule.forFeature([Product, Category])],
  controllers: [ProductsController, CategoriesController],
  providers: [ProductsService, CategoriesService],
  exports: [ProductsService],
})
export class ProductsModule {}

// Good - Main controller for primary route (products.controller.ts)
import { Controller, Get, Post, Body, Param, Query, Delete, Put } from '@nestjs/common';
import { ProductsService } from './services/products.service';
import { CreateProductDto } from './dto/create-product.dto';
import { UpdateProductDto } from './dto/update-product.dto';
import { ProductQueryDto } from './dto/product-query.dto';
import { ApiTags, ApiOperation } from '@nestjs/swagger';

@ApiTags('products')
@Controller('products')
export class ProductsController {
  constructor(private readonly productsService: ProductsService) {}

  @Post()
  @ApiOperation({ summary: 'Create a new product' })
  create(@Body() createProductDto: CreateProductDto) {
    return this.productsService.create(createProductDto);
  }

  @Get()
  @ApiOperation({ summary: 'Get all products with filtering' })
  findAll(@Query() query: ProductQueryDto) {
    return this.productsService.findAll(query);
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get a product by ID' })
  findOne(@Param('id') id: string) {
    return this.productsService.findOne(id);
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update a product' })
  update(@Param('id') id: string, @Body() updateProductDto: UpdateProductDto) {
    return this.productsService.update(id, updateProductDto);
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete a product' })
  remove(@Param('id') id: string) {
    return this.productsService.remove(id);
  }
}

// Good - Secondary controller for related route (categories.controller.ts)
import { Controller, Get, Param } from '@nestjs/common';
import { CategoriesService } from './services/categories.service';
import { ApiTags, ApiOperation } from '@nestjs/swagger';

@ApiTags('categories')
@Controller('categories')
export class CategoriesController {
  constructor(private readonly categoriesService: CategoriesService) {}

  @Get(':id/products')
  @ApiOperation({ summary: 'Get all products in a category' })
  getProductsInCategory(@Param('id') categoryId: string) {
    return this.categoriesService.getProductsByCategory(categoryId);
  }
}

// Good - DTO with validation (create-product.dto.ts)
import { IsString, IsNumber, IsNotEmpty, Min, IsOptional, IsArray, ValidateNested } from 'class-validator';
import { Type } from 'class-transformer';

export class FeatureDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsString()
  @IsNotEmpty()
  value: string;
}

export class CreateProductDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsNumber()
  @Min(0)
  price: number;

  @IsString()
  @IsNotEmpty()
  categoryId: string;

  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => FeatureDto)
  @IsOptional()
  features?: FeatureDto[];
}

// Good - Entity definition (product.entity.ts)
import { Entity, Column, PrimaryGeneratedColumn, ManyToOne, CreateDateColumn, UpdateDateColumn } from 'typeorm';
import { Category } from './category.entity';

@Entity('products')
export class Product {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  name: string;

  @Column({ nullable: true })
  description: string;

  @Column({ type: 'decimal', precision: 10, scale: 2 })
  price: number;

  @ManyToOne(() => Category, category => category.products)
  category: Category;

  @Column()
  categoryId: string;

  @Column({ type: 'json', nullable: true })
  features: Record<string, any>[];

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}

// Good - Service with business logic (products.service.ts)
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Product } from '../entities/product.entity';
import { CreateProductDto } from '../dto/create-product.dto';
import { UpdateProductDto } from '../dto/update-product.dto';
import { ProductQueryDto } from '../dto/product-query.dto';

@Injectable()
export class ProductsService {
  constructor(
    @InjectRepository(Product)
    private productsRepository: Repository<Product>,
  ) {}

  async create(createProductDto: CreateProductDto): Promise<Product> {
    const product = this.productsRepository.create(createProductDto);
    return this.productsRepository.save(product);
  }

  async findAll(query: ProductQueryDto): Promise<{ items: Product[]; total: number }> {
    const { page = 1, limit = 10, category, minPrice, maxPrice, search } = query;
    const skip = (page - 1) * limit;

    const queryBuilder = this.productsRepository.createQueryBuilder('product');

    if (category) {
      queryBuilder.andWhere('product.categoryId = :category', { category });
    }

    if (minPrice !== undefined) {
      queryBuilder.andWhere('product.price >= :minPrice', { minPrice });
    }

    if (maxPrice !== undefined) {
      queryBuilder.andWhere('product.price <= :maxPrice', { maxPrice });
    }

    if (search) {
      queryBuilder.andWhere('(product.name LIKE :search OR product.description LIKE :search)',
        { search: `%${search}%` });
    }

    const [items, total] = await queryBuilder
      .skip(skip)
      .take(limit)
      .orderBy('product.createdAt', 'DESC')
      .getManyAndCount();

    return { items, total };
  }

  async findOne(id: string): Promise<Product> {
    const product = await this.productsRepository.findOne({ where: { id } });
    if (!product) {
      throw new NotFoundException(`Product with ID ${id} not found`);
    }
    return product;
  }

  async update(id: string, updateProductDto: UpdateProductDto): Promise<Product> {
    await this.findOne(id); // Check if exists
    await this.productsRepository.update(id, updateProductDto);
    return this.findOne(id);
  }

  async remove(id: string): Promise<void> {
    const result = await this.productsRepository.delete(id);
    if (result.affected === 0) {
      throw new NotFoundException(`Product with ID ${id} not found`);
    }
  }
}
```

### 7. API Documentation

- (PASS/FAIL) Use Swagger/OpenAPI for API documentation.
- (PASS/FAIL) Document all endpoints with descriptive summaries and parameters.
- (PASS/FAIL) Include response examples and error scenarios.
- (PASS/FAIL) Organize endpoints with meaningful tags.
- (PASS/FAIL) Add authentication requirements to protected endpoints.

**Examples:**

```typescript
// Controller with proper Swagger documentation
@ApiTags('users')
@Controller('users')
export class UsersController {
  @Post()
  @ApiOperation({ summary: 'Create a new user' })
  @ApiResponse({ status: 201, description: 'User has been created successfully', type: UserResponseDto })
  @ApiResponse({ status: 400, description: 'Bad Request - Invalid data provided' })
  @ApiResponse({ status: 409, description: 'Conflict - User already exists' })
  create(@Body() createUserDto: CreateUserDto): Promise<UserResponseDto> {
    return this.usersService.create(createUserDto);
  }
}
```

### 8. Testing Guidelines

- (PASS/FAIL) Write unit tests for services and helpers.
- (PASS/FAIL) Write integration tests for controllers and repositories.
- (PASS/FAIL) Use E2E tests for critical user flows.
- (PASS/FAIL) Mock external dependencies.
- (PASS/FAIL) Maintain test isolation.
- (PASS/FAIL) Structure test files to mirror source files.

**Examples:**

```typescript
// Bad - Testing implementation details
describe('UserService', () => {
  it('should call the repository with correct parameters', async () => {
    const repositorySpy = jest.spyOn(userRepository, 'save');
    await service.createUser(mockUserData);
    expect(repositorySpy).toHaveBeenCalledWith(expect.objectContaining({
      username: mockUserData.username
    }));
  });
});

// Good - Testing behavior and outcomes
describe('UserService', () => {
  it('should create a user and return it without password', async () => {
    const result = await service.createUser(mockUserData);
    expect(result).toHaveProperty('id');
    expect(result.username).toBe(mockUserData.username);
    expect(result).not.toHaveProperty('password');
  });
});
```

```typescript
// Bad - No setup/teardown
describe('ProductsController', () => {
  let controller: ProductsController;

  beforeEach(() => {
    controller = new ProductsController(new ProductsService(repository));
  });

  it('should create a product', async () => {
    // Test that might affect other tests
  });
});

// Good - Proper test isolation with setup and teardown
describe('ProductsController', () => {
  let controller: ProductsController;
  let service: ProductsService;

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      controllers: [ProductsController],
      providers: [
        {
          provide: ProductsService,
          useValue: {
            create: jest.fn(),
            findAll: jest.fn(),
            findOne: jest.fn(),
            update: jest.fn(),
            remove: jest.fn(),
          },
        },
      ],
    }).compile();

    controller = moduleRef.get<ProductsController>(ProductsController);
    service = moduleRef.get<ProductsService>(ProductsService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should create a product', async () => {
    const dto = { name: 'Test Product', price: 99.99 };
    jest.spyOn(service, 'create').mockResolvedValue({ id: '1', ...dto } as Product);

    expect(await controller.create(dto)).toEqual({
      id: '1',
      name: 'Test Product',
      price: 99.99,
    });
    expect(service.create).toHaveBeenCalledWith(dto);
  });
});
```

```typescript
// Bad - Testing multiple things in one test
it('should handle user registration process', async () => {
  // Test email validation
  const invalidEmail = { username: 'test', password: 'password', email: 'invalid' };
  await expect(service.register(invalidEmail)).rejects.toThrow();

  // Test username uniqueness
  const duplicateUser = { username: 'existing', password: 'password', email: 'test@example.com' };
  await expect(service.register(duplicateUser)).rejects.toThrow();

  // Test successful registration
  const validUser = { username: 'newuser', password: 'password', email: 'new@example.com' };
  const result = await service.register(validUser);
  expect(result).toHaveProperty('id');
});

// Good - Single responsibility tests
describe('UserRegistration', () => {
  it('should reject invalid email formats', async () => {
    const invalidEmail = { username: 'test', password: 'password', email: 'invalid' };
    await expect(service.register(invalidEmail)).rejects.toThrow(/email format/i);
  });

  it('should reject duplicate usernames', async () => {
    const duplicateUser = { username: 'existing', password: 'password', email: 'test@example.com' };
    jest.spyOn(repository, 'findOne').mockResolvedValue({ id: '1', username: 'existing' } as User);

    await expect(service.register(duplicateUser)).rejects.toThrow(/username already exists/i);
  });

  it('should successfully register valid users', async () => {
    const validUser = { username: 'newuser', password: 'password', email: 'new@example.com' };
    jest.spyOn(repository, 'findOne').mockResolvedValue(null);
    jest.spyOn(repository, 'save').mockImplementation(user => Promise.resolve({ id: '1', ...user }));

    const result = await service.register(validUser);
    expect(result).toHaveProperty('id', '1');
    expect(result.username).toBe('newuser');
  });
});
```

```typescript
// Bad - E2E test with no setup/teardown
describe('Auth E2E', () => {
  it('should register and login', async () => {
    // Test that might leave data in the database
  });
});

// Good - Proper E2E testing
describe('Auth E2E', () => {
  let app: INestApplication;
  let moduleFixture: TestingModule;

  beforeAll(async () => {
    moduleFixture = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    app.useGlobalPipes(new ValidationPipe());
    await app.init();
  });

  afterAll(async () => {
    // Clean up test data
    const dataSource = app.get(DataSource);
    await dataSource.query('DELETE FROM users WHERE email = $1', ['test@example.com']);
    await app.close();
  });

  it('should register a new user', () => {
    return request(app.getHttpServer())
      .post('/auth/register')
      .send({
        username: 'testuser',
        email: 'test@example.com',
        password: 'password123',
      })
      .expect(201)
      .expect(res => {
        expect(res.body).toHaveProperty('id');
        expect(res.body.username).toBe('testuser');
        expect(res.body).not.toHaveProperty('password');
      });
  });

  it('should login with registered credentials', () => {
    return request(app.getHttpServer())
      .post('/auth/login')
      .send({
        username: 'testuser',
        password: 'password123',
      })
      .expect(200)
      .expect(res => {
        expect(res.body).toHaveProperty('accessToken');
      });
  });
});
```

### 9. TypeScript Guidelines

- (PASS/FAIL) Always declare types for variables and functions.
- (PASS/FAIL) Avoid using `any` type.
- (PASS/FAIL) Write short functions with a single purpose (less than 20 instructions).
- (PASS/FAIL) Follow naming conventions: PascalCase for classes, camelCase for variables/functions, kebab-case for files.
- (PASS/FAIL) Use prefixes for boolean variables (is/has/can/should).
- (PASS/FAIL) Avoid nesting blocks by using early returns.
- (PASS/FAIL) Prefer immutability for data.
- (PASS/FAIL) Follow SOLID principles.

**Examples:**

```typescript
// Bad - No type declarations
function processData(data) {
    const result = [];
    for (let i = 0; i < data.length; i++) {
        result.push(data[i].value * 2);
    }
    return result;
}

// Good - Proper type declarations
function processData(data: DataItem[]): number[] {
    const result: number[] = [];
    for (let i = 0; i < data.length; i++) {
        result.push(data[i].value * 2);
    }
    return result;
}
```

```typescript
// Bad - Using any type
function handleInput(input: any): any {
    // Process input somehow
    return input.data.map((item: any) => item.value);
}

// Good - Using proper types
interface InputData {
    data: { value: number }[];
}

function handleInput(input: InputData): number[] {
    return input.data.map(item => item.value);
}
```

```typescript
// Bad - Long function with multiple responsibilities
function processUserData(user: User): UserProfile {
    // Validate email
    if (!user.email || !user.email.includes('@')) {
        throw new Error('Invalid email');
    }

    // Hash password
    const hashedPassword = bcrypt.hashSync(user.password, 10);

    // Save to database
    const savedUser = database.save({...user, password: hashedPassword});

    // Format user profile
    const profile = {
        id: savedUser.id,
        displayName: `${savedUser.firstName} ${savedUser.lastName}`,
        email: savedUser.email,
        roles: savedUser.roles,
        lastLogin: new Date()
    };

    // Send welcome email
    emailService.sendWelcome(savedUser.email);

    return profile;
}

// Good - Single responsibility function
function createUserProfile(user: User): UserProfile {
    const validatedUser = validateUser(user);
    const securedUser = secureUserData(validatedUser);
    const savedUser = saveUserToDatabase(securedUser);
    const profile = formatUserProfile(savedUser);

    notifyUserCreation(savedUser);

    return profile;
}
```

```typescript
// Bad - Poor naming and no boolean prefixes
function check(u: User, perm: string): boolean {
    return u.perms.includes(perm);
}

// Good - Clear naming with boolean prefix
function hasPermission(user: User, permission: string): boolean {
    return user.permissions.includes(permission);
}
```

```typescript
// Bad - Deeply nested logic
function processOrder(order: Order): OrderResult {
    if (order.isValid) {
        if (order.items.length > 0) {
            if (order.paymentMethod) {
                if (order.paymentMethod.type === 'credit') {
                    // Process credit payment
                    return { success: true };
                } else {
                    return { success: false, error: 'Only credit accepted' };
                }
            } else {
                return { success: false, error: 'No payment method' };
            }
        } else {
            return { success: false, error: 'Empty order' };
        }
    } else {
        return { success: false, error: 'Invalid order' };
    }
}

// Good - Early returns to avoid nesting
function processOrder(order: Order): OrderResult {
    if (!order.isValid) {
        return { success: false, error: 'Invalid order' };
    }

    if (order.items.length === 0) {
        return { success: false, error: 'Empty order' };
    }

    if (!order.paymentMethod) {
        return { success: false, error: 'No payment method' };
    }

    if (order.paymentMethod.type !== 'credit') {
        return { success: false, error: 'Only credit accepted' };
    }

    // Process credit payment
    return { success: true };
}
```

```typescript
// Bad - Mutating data
function addItemToCart(cart: Cart, item: Item): void {
    cart.items.push(item);
    cart.total += item.price;
    cart.updated = new Date();
}

// Good - Immutable data handling
function addItemToCart(cart: Cart, item: Item): Cart {
    return {
        ...cart,
        items: [...cart.items, item],
        total: cart.total + item.price,
        updated: new Date()
    };
}
```

```typescript
// Bad - Not following SOLID principles (SRP violation)
class UserManager {
    async createUser(userData: UserData): Promise<User> {
        // Validate
        this.validateUserData(userData);

        // Hash password
        userData.password = await bcrypt.hash(userData.password, 10);

        // Save to DB
        const user = await this.userRepository.save(userData);

        // Send email
        await this.sendWelcomeEmail(user.email);

        return user;
    }

    private validateUserData(data: UserData): void {
        // Validation logic
    }

    private async sendWelcomeEmail(email: string): Promise<void> {
        // Email sending logic
    }
}

// Good - Following SOLID principles
@Injectable()
class UserService {
    constructor(
        private readonly validator: UserValidator,
        private readonly securityService: SecurityService,
        private readonly userRepository: UserRepository,
        private readonly notificationService: NotificationService
    ) {}

    async createUser(userData: UserData): Promise<User> {
        this.validator.validateUserData(userData);

        const secureData = await this.securityService.secureUserData(userData);
        const user = await this.userRepository.save(secureData);

        await this.notificationService.sendWelcomeEmail(user);

        return user;
    }
}
```

